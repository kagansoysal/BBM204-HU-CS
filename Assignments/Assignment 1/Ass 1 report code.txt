
\documentclass[11pt]{article}


% Use wide margins, but not quite so wide as fullpage.sty
\marginparwidth 0.2in 
\oddsidemargin 0.1in 
\evensidemargin 0.1in 
\marginparsep 0.1in
\topmargin 0.1in 
\textwidth 6.5in \textheight 8 in
% That's about enough definitions

% multirow allows you to combine rows in columns
\usepackage{multirow}
% tabularx allows manual tweaking of column width
\usepackage{tabularx}
% longtable does better format for tables that span pages
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{amssymb} % needed for math
\usepackage{amsmath} % needed for math
\usepackage{listings} % needed for the inclusion of source code
%\usepackage{mips}
\usepackage{color}
% this is needed for forms and links within the text
\usepackage{hyperref}  
\usepackage{xcolor}
\usepackage{listings}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}
\usepackage{courier} %% Sets font for listing as Courier.
\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{green}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
}


\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}

\begin{document}
% this is an alternate method of creating a title
%\hfill\vbox{\hbox{Gius, Mark}
%       \hbox{Cpe 456, Section 01}  
%       \hbox{Lab 1}    
%       \hbox{\today}}\par
%
%\bigskip
%\centerline{\Large\bf Lab 1: Security Audit}\par
%\bigskip
%\author{Name Surname, Student ID}
%\title{BBM233: Logic Design Lab\\2020 Fall\\Lab Experiment \#(add experiment no. here) Report}
%\maketitle


\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\center

\includegraphics[width=0.2\textwidth]{logo.png}
\vfill
\textsc{\LARGE Hacettepe University}\\[0.5cm]
\textsc{\Large Computer Engineering Department}\\[1.5cm]
\textsc{\large BBM204 Software Practicum II - 2024 Spring}\\[0.5cm]

\HRule \\[0.4cm]
{ \huge \bfseries Programming Assignment 1}\\[0.4cm] 
\HRule \\[0.3cm]
{\large \today}\\[2cm]
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Student name:}\\
Gazi Kağan \textsc{Soysal}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Student Number:} \\
b2210356050
\end{flushright}
\end{minipage}\\[2cm]
\vfill
\end{titlepage}



\section{Problem Definition}

Our goal when writing our codes is not only to ensure that the code works correctly, but also to make it take as little time as possible. Because when we process large data sets, it can take a very long time. If it takes too long, its usefulness in daily life applications decreases. As qualified engineers of the future, we must take this aspect of our projects into consideration.


\section{Solution Implementation}

After implementing some popular sort and search algorithms in our project, we compare the average times we obtained after running these algorithms with data sets of different sizes by creating a graph.

\subsection{Merge Sort Algorithm}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class SortAlgorithms {
    static int[] mergeSort(int[] datas) {
        int size = datas.length;

        if (size <= 1) return datas;
        int[] leftArray = Arrays.copyOfRange(datas, 0, size/2);
        int[] rightArray = Arrays.copyOfRange(datas, size/2, size);

        leftArray = mergeSort(leftArray);
        rightArray = mergeSort(rightArray);

        return merge(leftArray, rightArray);

    }

    static int[] merge(int[] left, int[] right) {
        int[] mergeArray = new int[left.length + right.length];

        int leftIndex = 0, rightIndex = 0, mergeIndex = 0;

        while (leftIndex < left.length || rightIndex < right.length) {
            if (leftIndex == left.length || (rightIndex < right.length && left[leftIndex] > right[rightIndex])) {
                mergeArray[mergeIndex++] = right[rightIndex++];
            } else if (rightIndex == right.length || (leftIndex < left.length && left[leftIndex] <= right[rightIndex])) {
                mergeArray[mergeIndex++] = left[leftIndex++];
            }
        }

        return mergeArray;
    }}
\end{lstlisting}

\subsection{Insertion Sort Algorithm}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class SortAlgorithms {
    static int[] insertionSort(int[] datas) {
        for (int j=1; j < datas.length; j++) {
            int key = datas[j];
            int i = j-1;

            while (i >= 0 && datas[i] > key) {
                datas[i+1] = datas[i];
                i--;
            }
            datas[i+1] = key;
        }
        return datas;
    }
}
\end{lstlisting}

\subsection{Counting Sort Algorithm}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class SortAlgorithm {
    static  int[] countingSort(int[] datas) {
        int maxValue = Utilities.findMax(datas);

        int[] count = new int[maxValue + 1];
        int[] output = new int[datas.length];

        for (int i : datas) count[i]++;
        for (int i = 1; i < maxValue+1; i++)
            count[i] = count[i] + count[i - 1];

        for (int i = datas.length-1; i >= 0; i--) {
            int j = datas[i];
            count[j]--;
            output[count[j]] = datas[i];
        }
        return output;
    }
}
\end{lstlisting}

\newpage

\subsection{Linear Search Algorithm}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class SearchAlgorithms {
    static int linearSearch(int[] datas, int value) {
        for (int i = 0; i < datas.length; i++) {
            if (datas[i] == value) return i;
        }
        return -1;
    }
}
\end{lstlisting}



\subsection{Binary Search Algorithm}

\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class SortAlgorithms {
    static int binarySearch(int[] datas, int value) {
        int low = 0;
        int high = datas.length - 1;

        while (high - low > 1) {
            int mid = (high + low) / 2;

            if (datas[mid] < value) low = mid + 1;
            else high = mid;
        }

        if (datas[low] == value) return low;
        else if (datas[high] == value) return high;

        return -1;
    }
}
\end{lstlisting}

\newpage

\section{Results, Analysis, Discussion}

\begin{table}[ht!]
\centering
\caption{Results of the running time tests performed for varying input sizes (in ms).}
\label{tab:results}
\resizebox{\textwidth}{!}{%
\scriptsize
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|} \hline
\multicolumn{1}{c}{\multirow{2}{*}{\textbf{}}} & \multicolumn{10}{c}{\textbf{Input Size $n$}}                                       \\ \hline
\multicolumn{1}{|c|}{\textbf{Algorithm}}                           & \textbf{500} & \textbf{1000} & \textbf{2000} & \textbf{4000} & \textbf{8000} & \textbf{16000} & \textbf{32000} & \textbf{64000} & \textbf{128000} & \textbf{250000} \\  \hline
                                               & \multicolumn{10}{c|}{\textbf{Random Input Data Timing Results in ms}}                                    \\ \hline
Insertion sort                                 &  0.3   &  0.1    &  0.2    &  0.7    &  2.6    &  11.2     &  41.8     &  162.4     &  672.9      &     2774.4   \\ \hline
Merge sort                                     & 0.1    &  0.0    &  0.1    &   0.3   &  0.6    &  1.2     &  2.5     &  5.6     &  11.7      &  25.0      \\ \hline
Counting sort                                    & 117.3    &  93.5    & 91.8     &  96.6    &  92.9    &  92.6     &   92.5    &  94.7     & 102.3       &   96.9     \\ \hline
                                               & \multicolumn{10}{c|}{\textbf{Sorted Input Data Timing Results in ms}}                                    \\ \hline
Insertion sort                                 &  0.0   &  0.0    & 0.0     &  0.0    &  0.0    &  0.0     &  0.1     &   0.0    &   0.2     &  0.4      \\ \hline
Merge sort                                     & 0.0    &  0.0    & 0.0     &   0.2   &  0.3    &  0.6     &     1.1  &  2.6     &    5.2    &   10.6     \\ \hline
Counting sort                                    &  92.9   & 93.9     & 92.8     &  92.7    &  93.2    &  91.7     &  92.2     &  94.8     & 93.4       &  95.3      \\ \hline
                                               & \multicolumn{10}{c|}{\textbf{Reversely Sorted Input Data Timing Results in ms}}                          \\ \hline
Insertion sort                                 & 0.1 & 0.1 &  0.3    &  1.2    &  5.3    &  20.2     &   81.9    &  328.6     &   1338.7     &  4906.8      \\ \hline
Merge sort                                     &  0.0   &  0.0    &  0.1    &   0.2   &  0.3    &   0.5    &   1.2    &   2.4    &  4.8      &   11.2     \\ \hline
Counting sort                                    & 93.8    &  94.2    & 93.6     &   95.8   &  93.2    &  94.1     &  92.5     &  96.3     &  96.3     &  97.2     \\ \hline
\end{tabular}
}
\end{table}
 

\begin{table}[ht!]
\centering
\caption{Results of the running time tests of search algorithms of varying sizes (in ns).}
\label{tab:searchresults}
\resizebox{\textwidth}{!}{%
\scriptsize
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|} \hline
\multicolumn{1}{c}{\multirow{2}{*}{\textbf{}}} & \multicolumn{10}{c}{\textbf{Input Size $n$}}                                       \\ \hline
\multicolumn{1}{|c|}{\textbf{Algorithm}}                           & \textbf{500} & \textbf{1000} & \textbf{2000} & \textbf{4000} & \textbf{8000} & \textbf{16000} & \textbf{32000} & \textbf{64000} & \textbf{128000} & \textbf{250000} \\  \hline
                                             
Linear search (random data)                                  &  1749.0   & 245.2     &   180.6   & 248.3     & 420.1     & 988.5      &  1052.9     & 2410.7      &  4999.7      &  12301.6      \\ \hline
Linear search (sorted data)                                      & 718.5    & 120.4     &  171.6    & 275.8     & 556.8     & 1079.5      & 2118.4      & 4159.3      & 8676.8 & 16662.0       \\ \hline
Binary search (sorted data)                                    &  162.3   & 71.3     &  96.6    & 51.7     & 40.4     & 45.4      & 49.9      & 41.0      &  45.5      &    46.1    \\  \hline
\end{tabular}
}
\end{table}


    \begin{table}[!ht]
    \centering
\caption{Computational complexity comparison of the given algorithms.}\label{tab:resultscomplexity}
    \begin{tabular}{llll}
    \toprule
    \textbf{Algorithm}       & \textbf{Best Case}       & \textbf{Average Case}    & \textbf{Worst Case}      \\ \toprule
    Insertion sort & $\Omega(n)$        & $\Theta(n^2)$       & $O(n^2)$       \\
    Merge sort     & $\Omega(n \log n)$ & $\Theta(n \log n )$ & $O(n \log n)$ \\
    Counting Sort     &   $\Omega(n + k)$      &$\Theta(n + k )$      &  $O(n+k)$     \\ 
    Linear Search     &   $\Omega(1)$      &  $\Theta(n )$    &   $O(n)$    \\ 
    Binary Search     & $\Omega(1)$      &   $\Theta(\log n )$      & $O(n\log n)$    \\\bottomrule
    \end{tabular}
    \end{table}

    \begin{itemize}
    \item {Since the best case of sort algorithms is sorted cases, the best case comes out better in insertion sort, but the complexity does not change since other algorithms will perform the same operation even if they are sorted.}
\end{itemize}


\newpage


    \begin{table}[!ht]
    \centering
\caption{Auxiliary space complexity of the given algorithms.}\label{tab:spacecomplexity}
    \begin{tabular}{@{}ll@{}}
    \toprule
    \textbf{Algorithm}      & \begin{tabular}[c]{@{}l@{}}\textbf{Auxiliary Space}\\ \textbf{Complexity}\end{tabular} \\ \midrule
    Insertion sort & $O(1)$                     \\
    Merge sort     & $O(n)$                     \\
    Counting sort     &    $O(k)$      \\ 
    Linear Search     &  $O(1)$       \\ 
    Binary Search     &  $O(1)$      \\\bottomrule
    \end{tabular}
    
    \end{table}

    \begin{itemize}
    \item {Insertion Sort: No extra space is assigned in this algorithm. It operates in-place, thereby resulting in an auxiliary space complexity of O(1).}
    \item {Merge Sort: These lines demonstrate the creation of supplementary arrays (left, right, C) to store intermediate results throughout the merge sort procedure. Consequently, the auxiliary space complexity amounts to O(n).} \newline        Line 6: left ← A[1]...A[n/2] \newline   Line 7: right ← A[n/2+1]...A[n] \newline   Line 13: C: array
 
 \item {Counting Sort: These lines reserve extra space for the count array and the output array. The dimensions of these arrays are contingent on the range of elements within the input array, represented by k. As a result, the auxiliary space complexity becomes O(k + n).} \newline Line 2: count ← array of k + 1 zeros \newline
Line 3: output ← array of the same length as A

\item {Linear Search:
This algorithm does not assign any extra space. It operates solely using a fixed amount of additional space for storing loop counters and temporary variables. Hence, the auxiliary space complexity remains O(1).}
\item {Binary Search:
No extra space is assigned in this algorithm. It operates solely with a constant amount of additional space for storing loop counters and temporary variables. Hence, the auxiliary space complexity remains O(1).}
\end{itemize}




\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{Tests on Random Data.png}
    \caption{Tests on Random Data}
    \label{fig:enter-label}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{Tests on Sort Data.png}
    \caption{Tests on Sorted Data}
    \label{fig:enter-label}
\end{figure}

\begin{figure}
        \centering
        \includegraphics[width=0.7\linewidth]{Tests on Reverse Data.png}
        \caption{Tests on Reverse Data}
        \label{fig:enter-label}
    \end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.7\linewidth]{Tests of Search Algorithms.png}
    \caption{Tests of Search Algorithms}
    \label{fig:enter-label}
\end{figure}

    

\newpage



\section{Notes}

\begin{itemize}
    \item {When working with random data or reverse data, working with the insertion sort algorithm takes a lot of time for large data sizes. Therefore, it would be more useful to use merge sort or counting sort algorithms to improve performance when working with this data.}
    \item {Algorithms will take much less time when working with already sorted data. However, in our chart, the counting sort algorithm takes longer than others. I guess this may be due to the data range we are working with being too high.}
    \item {While analyzing the search algorithms, I tried to choose the value to be searched in a balanced way so that the results would be more consistent. For this reason, I chose 10 values to search and these values are evenly distributed in the data. Additionally, as can be seen from our graph, the binary search algorithm is a much more efficient algorithm compared to linear.}
\end{itemize}


\end{document}
